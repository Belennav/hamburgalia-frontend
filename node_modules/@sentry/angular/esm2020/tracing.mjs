import { Directive, Injectable, Input, NgModule } from '@angular/core';
// Duplicated import to work around a TypeScript bug where it'd complain that `Router` isn't imported as a type.
// We need to import it as a value to satisfy Angular dependency injection. So:
// eslint-disable-next-line @typescript-eslint/consistent-type-imports
import { NavigationCancel, NavigationError } from '@angular/router';
import { NavigationEnd, NavigationStart, ResolveEnd } from '@angular/router';
import { SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, browserTracingIntegration as originalBrowserTracingIntegration, getActiveSpan, getClient, getCurrentScope, getRootSpan, spanToJSON, startBrowserTracingNavigationSpan, startInactiveSpan, } from '@sentry/browser';
import { logger, stripUrlQueryAndFragment, timestampInSeconds } from '@sentry/core';
import { Subscription } from 'rxjs';
import { filter, tap } from 'rxjs/operators';
import { ANGULAR_INIT_OP, ANGULAR_OP, ANGULAR_ROUTING_OP } from './constants';
import { IS_DEBUG_BUILD } from './flags';
import { runOutsideAngular } from './zone';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
let instrumentationInitialized;
/**
 * A custom browser tracing integration for Angular.
 *
 * Use this integration in combination with `TraceService`
 */
export function browserTracingIntegration(options = {}) {
    // If the user opts out to set this up, we just don't initialize this.
    // That way, the TraceService will not actually do anything, functionally disabling this.
    if (options.instrumentNavigation !== false) {
        instrumentationInitialized = true;
    }
    return originalBrowserTracingIntegration({
        ...options,
        instrumentNavigation: false,
    });
}
/**
 * This function is extracted to make unit testing easier.
 */
export function _updateSpanAttributesForParametrizedUrl(route, span) {
    const attributes = (span && spanToJSON(span).data) || {};
    if (span && attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] === 'url') {
        span.updateName(route);
        span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, 'route');
        span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, `auto.${spanToJSON(span).op}.angular`);
    }
}
/**
 * Angular's Service responsible for hooking into Angular Router and tracking current navigation process.
 * Creates a new transaction for every route change and measures a duration of routing process.
 */
export class TraceService {
    constructor(_router) {
        this._router = _router;
        this.navStart$ = this._router.events.pipe(filter((event) => event instanceof NavigationStart), tap(navigationEvent => {
            if (!instrumentationInitialized) {
                IS_DEBUG_BUILD &&
                    logger.error('Angular integration has tracing enabled, but Tracing integration is not configured');
                return;
            }
            if (this._routingSpan) {
                this._routingSpan.end();
                this._routingSpan = null;
            }
            const client = getClient();
            const strippedUrl = stripUrlQueryAndFragment(navigationEvent.url);
            if (client) {
                // see comment in `_isPageloadOngoing` for rationale
                if (!this._isPageloadOngoing()) {
                    runOutsideAngular(() => {
                        startBrowserTracingNavigationSpan(client, {
                            name: strippedUrl,
                            attributes: {
                                [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.angular',
                                [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',
                            },
                        });
                    });
                }
                else {
                    // The first time we end up here, we set the pageload flag to false
                    // Subsequent navigations are going to get their own navigation root span
                    // even if the pageload root span is still ongoing.
                    this._pageloadOngoing = false;
                }
                this._routingSpan =
                    runOutsideAngular(() => startInactiveSpan({
                        name: `${navigationEvent.url}`,
                        op: ANGULAR_ROUTING_OP,
                        attributes: {
                            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.angular',
                            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',
                            url: strippedUrl,
                            ...(navigationEvent.navigationTrigger && {
                                navigationTrigger: navigationEvent.navigationTrigger,
                            }),
                        },
                    })) || null;
                return;
            }
        }));
        // The ResolveEnd event is fired when the Angular router has resolved the URL and
        // the parameter<->value mapping. It holds the new resolved router state with
        // the mapping and the new URL.
        // Only After this event, the route is activated, meaning that the transaction
        // can be updated with the parameterized route name before e.g. the route's root
        // component is initialized. This should be early enough before outgoing requests
        // are made from the new route, with the exceptions of requests being made during
        // a navigation.
        this.resEnd$ = this._router.events.pipe(filter((event) => event instanceof ResolveEnd), tap(event => {
            const route = getParameterizedRouteFromSnapshot(event.state.root);
            if (route) {
                getCurrentScope().setTransactionName(route);
            }
            const activeSpan = getActiveSpan();
            const rootSpan = activeSpan && getRootSpan(activeSpan);
            _updateSpanAttributesForParametrizedUrl(route, rootSpan);
        }));
        this.navEnd$ = this._router.events.pipe(filter(event => event instanceof NavigationEnd || event instanceof NavigationCancel || event instanceof NavigationError), tap(() => {
            if (this._routingSpan) {
                runOutsideAngular(() => {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this._routingSpan.end();
                });
                this._routingSpan = null;
            }
        }));
        this._routingSpan = null;
        this._pageloadOngoing = true;
        this._subscription = new Subscription();
        this._subscription.add(this.navStart$.subscribe());
        this._subscription.add(this.resEnd$.subscribe());
        this._subscription.add(this.navEnd$.subscribe());
    }
    /**
     * This is used to prevent memory leaks when the root view is created and destroyed multiple times,
     * since `subscribe` callbacks capture `this` and prevent many resources from being GC'd.
     */
    ngOnDestroy() {
        this._subscription.unsubscribe();
    }
    /**
     * We only _avoid_ creating a navigation root span in one case:
     *
     * There is an ongoing pageload span AND the router didn't yet emit the first navigation start event
     *
     * The first navigation start event will create the child routing span
     * and update the pageload root span name on ResolveEnd.
     *
     * There's an edge case we need to avoid here: If the router fires the first navigation start event
     * _after_ the pageload root span finished. This is why we check for the pageload root span.
     * Possible real-world scenario: Angular application and/or router is bootstrapped after the pageload
     * idle root span finished
     *
     * The overall rationale is:
     * - if we already avoided creating a navigation root span once, we don't avoid it again
     *   (i.e. set `_pageloadOngoing` to `false`)
     * - if `_pageloadOngoing` is already `false`, create a navigation root span
     * - if there's no active/pageload root span, create a navigation root span
     * - only if there's an ongoing pageload root span AND `_pageloadOngoing` is still `true,
     *   don't create a navigation root span
     */
    _isPageloadOngoing() {
        if (!this._pageloadOngoing) {
            // pageload is already finished, no need to update
            return false;
        }
        const activeSpan = getActiveSpan();
        if (!activeSpan) {
            this._pageloadOngoing = false;
            return false;
        }
        const rootSpan = getRootSpan(activeSpan);
        this._pageloadOngoing = spanToJSON(rootSpan).op === 'pageload';
        return this._pageloadOngoing;
    }
}
TraceService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceService, deps: [{ token: i1.Router }], target: i0.ɵɵFactoryTarget.Injectable });
TraceService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.Router }]; } });
const UNKNOWN_COMPONENT = 'unknown';
/**
 * A directive that can be used to capture initialization lifecycle of the whole component.
 */
export class TraceDirective {
    /**
     * Implementation of OnInit lifecycle method
     * @inheritdoc
     */
    ngOnInit() {
        if (!this.componentName) {
            this.componentName = UNKNOWN_COMPONENT;
        }
        if (getActiveSpan()) {
            this._tracingSpan = runOutsideAngular(() => startInactiveSpan({
                name: `<${this.componentName}>`,
                op: ANGULAR_INIT_OP,
                attributes: { [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.angular.trace_directive' },
            }));
        }
    }
    /**
     * Implementation of AfterViewInit lifecycle method
     * @inheritdoc
     */
    ngAfterViewInit() {
        if (this._tracingSpan) {
            runOutsideAngular(() => this._tracingSpan.end());
        }
    }
}
TraceDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
TraceDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.3.0", type: TraceDirective, selector: "[trace]", inputs: { componentName: ["trace", "componentName"] }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceDirective, decorators: [{
            type: Directive,
            args: [{ selector: '[trace]' }]
        }], propDecorators: { componentName: [{
                type: Input,
                args: ['trace']
            }] } });
/**
 * A module serves as a single compilation unit for the `TraceDirective` and can be re-used by any other module.
 */
export class TraceModule {
}
TraceModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TraceModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.3.0", ngImport: i0, type: TraceModule, declarations: [TraceDirective], exports: [TraceDirective] });
TraceModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: TraceModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [TraceDirective],
                    exports: [TraceDirective],
                }]
        }] });
/**
 * Decorator function that can be used to capture initialization lifecycle of the whole component.
 */
export function TraceClass(options) {
    let tracingSpan;
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    return target => {
        const originalOnInit = target.prototype.ngOnInit;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        target.prototype.ngOnInit = function (...args) {
            tracingSpan = runOutsideAngular(() => startInactiveSpan({
                onlyIfParent: true,
                name: `<${options && options.name ? options.name : 'unnamed'}>`,
                op: ANGULAR_INIT_OP,
                attributes: {
                    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.angular.trace_class_decorator',
                },
            }));
            if (originalOnInit) {
                return originalOnInit.apply(this, args);
            }
        };
        const originalAfterViewInit = target.prototype.ngAfterViewInit;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        target.prototype.ngAfterViewInit = function (...args) {
            if (tracingSpan) {
                runOutsideAngular(() => tracingSpan.end());
            }
            if (originalAfterViewInit) {
                return originalAfterViewInit.apply(this, args);
            }
        };
    };
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
}
/**
 * Decorator function that can be used to capture a single lifecycle methods of the component.
 */
export function TraceMethod(options) {
    // eslint-disable-next-line @typescript-eslint/ban-types
    return (target, propertyKey, descriptor) => {
        const originalMethod = descriptor.value;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        descriptor.value = function (...args) {
            const now = timestampInSeconds();
            runOutsideAngular(() => {
                startInactiveSpan({
                    onlyIfParent: true,
                    name: `<${options && options.name ? options.name : 'unnamed'}>`,
                    op: `${ANGULAR_OP}.${String(propertyKey)}`,
                    startTime: now,
                    attributes: {
                        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.angular.trace_method_decorator',
                    },
                }).end(now);
            });
            if (originalMethod) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                return originalMethod.apply(this, args);
            }
        };
        return descriptor;
    };
}
/**
 * Takes the parameterized route from a given ActivatedRouteSnapshot and concatenates the snapshot's
 * child route with its parent to produce the complete parameterized URL of the activated route.
 * This happens recursively until the last child (i.e. the end of the URL) is reached.
 *
 * @param route the ActivatedRouteSnapshot of which its path and its child's path is concatenated
 *
 * @returns the concatenated parameterized route string
 */
export function getParameterizedRouteFromSnapshot(route) {
    const parts = [];
    let currentRoute = route && route.firstChild;
    while (currentRoute) {
        const path = currentRoute && currentRoute.routeConfig && currentRoute.routeConfig.path;
        if (path === null || path === undefined) {
            break;
        }
        parts.push(path);
        currentRoute = currentRoute.firstChild;
    }
    const fullPath = parts.filter(part => part).join('/');
    return fullPath ? `/${fullPath}/` : '/';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhY2luZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90cmFjaW5nLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFdkUsZ0hBQWdIO0FBQ2hILCtFQUErRTtBQUMvRSxzRUFBc0U7QUFDdEUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLGVBQWUsRUFBVSxNQUFNLGlCQUFpQixDQUFDO0FBQzVFLE9BQU8sRUFBRSxhQUFhLEVBQUUsZUFBZSxFQUFFLFVBQVUsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzdFLE9BQU8sRUFDTCxnQ0FBZ0MsRUFDaEMsZ0NBQWdDLEVBQ2hDLHlCQUF5QixJQUFJLGlDQUFpQyxFQUM5RCxhQUFhLEVBQ2IsU0FBUyxFQUNULGVBQWUsRUFDZixXQUFXLEVBQ1gsVUFBVSxFQUNWLGlDQUFpQyxFQUNqQyxpQkFBaUIsR0FDbEIsTUFBTSxpQkFBaUIsQ0FBQztBQUN6QixPQUFPLEVBQUUsTUFBTSxFQUFFLHdCQUF3QixFQUFFLGtCQUFrQixFQUFFLE1BQU0sY0FBYyxDQUFDO0FBR3BGLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDcEMsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUU3QyxPQUFPLEVBQUUsZUFBZSxFQUFFLFVBQVUsRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUM5RSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBQ3pDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLFFBQVEsQ0FBQzs7O0FBRTNDLElBQUksMEJBQW1DLENBQUM7QUFFeEM7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSx5QkFBeUIsQ0FDdkMsVUFBbUUsRUFBRTtJQUVyRSxzRUFBc0U7SUFDdEUseUZB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O0FBQ0osQ0FBQztBQUVEOzs7Ozs7OztHQVFHO0FBQ0gsTUFBTSxVQUFVLGlDQUFpQyxDQUFDLEtBQXFDO0lBQ3JGLE1BQU0sS0FBSyxHQUFhLEVBQUUsQ0FBQztJQUUzQixJQUFJLFlBQVksR0FBRyxLQUFLLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQztJQUM3QyxPQUFPLFlBQVksRUFBRTtRQUNuQixNQUFNLElBQUksR0FBRyxZQUFZLElBQUksWUFBWSxDQUFDLFdBQVcsSUFBSSxZQUFZLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztRQUN2RixJQUFJLElBQUksS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLFNBQVMsRUFBRTtZQUN2QyxNQUFNO1NBQ1A7UUFFRCxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2pCLFlBQVksR0FBRyxZQUFZLENBQUMsVUFBVSxDQUFDO0tBQ3hDO0lBRUQsTUFBTSxRQUFRLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN0RCxPQUFPLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxRQUFRLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQzFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEaXJlY3RpdmUsIEluamVjdGFibGUsIElucHV0LCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHR5cGUgeyBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBFdmVudCwgUm91dGVyU3RhdGUgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuLy8gRHVwbGljYXRlZCBpbXBvcnQgdG8gd29yayBhcm91bmQgYSBUeXBlU2NyaXB0IGJ1ZyB3aGVyZSBpdCdkIGNvbXBsYWluIHRoYXQgYFJvdXRlcmAgaXNuJ3QgaW1wb3J0ZWQgYXMgYSB0eXBlLlxuLy8gV2UgbmVlZCB0byBpbXBvcnQgaXQgYXMgYSB2YWx1ZSB0byBzYXRpc2Z5IEFuZ3VsYXIgZGVwZW5kZW5jeSBpbmplY3Rpb24uIFNvOlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9jb25zaXN0ZW50LXR5cGUtaW1wb3J0c1xuaW1wb3J0IHsgTmF2aWdhdGlvbkNhbmNlbCwgTmF2aWdhdGlvbkVycm9yLCBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkVuZCwgTmF2aWdhdGlvblN0YXJ0LCBSZXNvbHZlRW5kIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7XG4gIFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOLFxuICBTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRSxcbiAgYnJvd3NlclRyYWNpbmdJbnRlZ3JhdGlvbiBhcyBvcmlnaW5hbEJyb3dzZXJUcmFjaW5nSW50ZWdyYXRpb24sXG4gIGdldEFjdGl2ZVNwYW4sXG4gIGdldENsaWVudCxcbiAgZ2V0Q3VycmVudFNjb3BlLFxuICBnZXRSb290U3BhbixcbiAgc3BhblRvSlNPTixcbiAgc3RhcnRCcm93c2VyVHJhY2luZ05hdmlnYXRpb25TcGFuLFxuICBzdGFydEluYWN0aXZlU3Bhbixcbn0gZnJvbSAnQHNlbnRyeS9icm93c2VyJztcbmltcG9ydCB7IGxvZ2dlciwgc3RyaXBVcmxRdWVyeUFuZEZyYWdtZW50LCB0aW1lc3RhbXBJblNlY29uZHMgfSBmcm9tICdAc2VudHJ5L2NvcmUnO1xuaW1wb3J0IHR5cGUgeyBJbnRlZ3JhdGlvbiwgU3BhbiB9IGZyb20gJ0BzZW50cnkvdHlwZXMnO1xuaW1wb3J0IHR5cGUgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBBTkdVTEFSX0lOSVRfT1AsIEFOR1VMQVJfT1AsIEFOR1VMQVJfUk9VVElOR19PUCB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IElTX0RFQlVHX0JVSUxEIH0gZnJvbSAnLi9mbGFncyc7XG5pbXBvcnQgeyBydW5PdXRzaWRlQW5ndWxhciB9IGZyb20gJy4vem9uZSc7XG5cbmxldCBpbnN0cnVtZW50YXRpb25Jbml0aWFsaXplZDogYm9vbGVhbjtcblxuLyoqXG4gKiBBIGN1c3RvbSBicm93c2VyIHRyYWNpbmcgaW50ZWdyYXRpb24gZm9yIEFuZ3VsYXIuXG4gKlxuICogVXNlIHRoaXMgaW50ZWdyYXRpb24gaW4gY29tYmluYXRpb24gd2l0aCBgVHJhY2VTZXJ2aWNlYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYnJvd3NlclRyYWNpbmdJbnRlZ3JhdGlvbihcbiAgb3B0aW9uczogUGFyYW1ldGVyczx0eXBlb2Ygb3JpZ2luYWxCcm93c2VyVHJhY2luZ0ludGVncmF0aW9uPlswXSA9IHt9LFxuKTogSW50ZWdyYXRpb24ge1xuICAvLyBJZiB0aGUgdXNlciBvcHRzIG91dCB0byBzZXQgdGhpcyB1cCwgd2UganVzdCBkb24ndCBpbml0aWFsaXplIHRoaXMuXG4gIC8vIFRoYXQgd2F5LCB0aGUgVHJhY2VTZXJ2aWNlIHdpbGwgbm90IGFjdHVhbGx5IGRvIGFueXRoaW5nLCBmdW5jdGlvbmFsbHkgZGlzYWJsaW5nIHRoaXMuXG4gIGlmIChvcHRpb25zLmluc3RydW1lbnROYXZpZ2F0aW9uICE9PSBmYWxzZSkge1xuICAgIGluc3RydW1lbnRhdGlvbkluaXRpYWxpemVkID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBvcmlnaW5hbEJyb3dzZXJUcmFjaW5nSW50ZWdyYXRpb24oe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgaW5zdHJ1bWVudE5hdmlnYXRpb246IGZhbHNlLFxuICB9KTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGV4dHJhY3RlZCB0byBtYWtlIHVuaXQgdGVzdGluZyBlYXNpZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfdXBkYXRlU3BhbkF0dHJpYnV0ZXNGb3JQYXJhbWV0cml6ZWRVcmwocm91dGU6IHN0cmluZywgc3Bhbj86IFNwYW4pOiB2b2lkIHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IChzcGFuICYmIHNwYW5Ub0pTT04oc3BhbikuZGF0YSkgfHwge307XG5cbiAgaWYgKHNwYW4gJiYgYXR0cmlidXRlc1tTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV0gPT09ICd1cmwnKSB7XG4gICAgc3Bhbi51cGRhdGVOYW1lKHJvdXRlKTtcbiAgICBzcGFuLnNldEF0dHJpYnV0ZShTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRSwgJ3JvdXRlJyk7XG4gICAgc3Bhbi5zZXRBdHRyaWJ1dGUoU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU4sIGBhdXRvLiR7c3BhblRvSlNPTihzcGFuKS5vcH0uYW5ndWxhcmApO1xuICB9XG59XG5cbi8qKlxuICogQW5ndWxhcidzIFNlcnZpY2UgcmVzcG9uc2libGUgZm9yIGhvb2tpbmcgaW50byBBbmd1bGFyIFJvdXRlciBhbmQgdHJhY2tpbmcgY3VycmVudCBuYXZpZ2F0aW9uIHByb2Nlc3MuXG4gKiBDcmVhdGVzIGEgbmV3IHRyYW5zYWN0aW9uIGZvciBldmVyeSByb3V0ZSBjaGFuZ2UgYW5kIG1lYXN1cmVzIGEgZHVyYXRpb24gb2Ygcm91dGluZyBwcm9jZXNzLlxuICovXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIFRyYWNlU2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHB1YmxpYyBuYXZTdGFydCQ6IE9ic2VydmFibGU8RXZlbnQ+ID0gdGhpcy5fcm91dGVyLmV2ZW50cy5waXBlKFxuICAgIGZpbHRlcigoZXZlbnQpOiBldmVudCBpcyBOYXZpZ2F0aW9uU3RhcnQgPT4gZXZlbnQgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uU3RhcnQpLFxuICAgIHRhcChuYXZpZ2F0aW9uRXZlbnQgPT4ge1xuICAgICAgaWYgKCFpbnN0cnVtZW50YXRpb25Jbml0aWFsaXplZCkge1xuICAgICAgICBJU19ERUJVR19CVUlMRCAmJlxuICAgICAgICAgIGxvZ2dlci5lcnJvcignQW5ndWxhciBpbnRlZ3JhdGlvbiBoYXMgdHJhY2luZyBlbmFibGVkLCBidXQgVHJhY2luZyBpbnRlZ3JhdGlvbiBpcyBub3QgY29uZmlndXJlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9yb3V0aW5nU3Bhbikge1xuICAgICAgICB0aGlzLl9yb3V0aW5nU3Bhbi5lbmQoKTtcbiAgICAgICAgdGhpcy5fcm91dGluZ1NwYW4gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnQoKTtcbiAgICAgIGNvbnN0IHN0cmlwcGVkVXJsID0gc3RyaXBVcmxRdWVyeUFuZEZyYWdtZW50KG5hdmlnYXRpb25FdmVudC51cmwpO1xuXG4gICAgICBpZiAoY2xpZW50KSB7XG4gICAgICAgIC8vIHNlZSBjb21tZW50IGluIGBfaXNQYWdlbG9hZE9uZ29pbmdgIGZvciByYXRpb25hbGVcbiAgICAgICAgaWYgKCF0aGlzLl9pc1BhZ2Vsb2FkT25nb2luZygpKSB7XG4gICAgICAgICAgcnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgc3RhcnRCcm93c2VyVHJhY2luZ05hdmlnYXRpb25TcGFuKGNsaWVudCwge1xuICAgICAgICAgICAgICBuYW1lOiBzdHJpcHBlZFVybCxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIFtTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTl06ICdhdXRvLm5hdmlnYXRpb24uYW5ndWxhcicsXG4gICAgICAgICAgICAgICAgW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXTogJ3VybCcsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGUgZmlyc3QgdGltZSB3ZSBlbmQgdXAgaGVyZSwgd2Ugc2V0IHRoZSBwYWdlbG9hZCBmbGFnIHRvIGZhbHNlXG4gICAgICAgICAgLy8gU3Vic2VxdWVudCBuYXZpZ2F0aW9ucyBhcmUgZ29pbmcgdG8gZ2V0IHRoZWlyIG93biBuYXZpZ2F0aW9uIHJvb3Qgc3BhblxuICAgICAgICAgIC8vIGV2ZW4gaWYgdGhlIHBhZ2Vsb2FkIHJvb3Qgc3BhbiBpcyBzdGlsbCBvbmdvaW5nLlxuICAgICAgICAgIHRoaXMuX3BhZ2Vsb2FkT25nb2luZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcm91dGluZ1NwYW4gPVxuICAgICAgICAgIHJ1bk91dHNpZGVBbmd1bGFyKCgpID0+XG4gICAgICAgICAgICBzdGFydEluYWN0aXZlU3Bhbih7XG4gICAgICAgICAgICAgIG5hbWU6IGAke25hdmlnYXRpb25FdmVudC51cmx9YCxcbiAgICAgICAgICAgICAgb3A6IEFOR1VMQVJfUk9VVElOR19PUCxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIFtTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTl06ICdhdXRvLnVpLmFuZ3VsYXInLFxuICAgICAgICAgICAgICAgIFtTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV06ICd1cmwnLFxuICAgICAgICAgICAgICAgIHVybDogc3RyaXBwZWRVcmwsXG4gICAgICAgICAgICAgICAgLi4uKG5hdmlnYXRpb25FdmVudC5uYXZpZ2F0aW9uVHJpZ2dlciAmJiB7XG4gICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uVHJpZ2dlcjogbmF2aWdhdGlvbkV2ZW50Lm5hdmlnYXRpb25UcmlnZ2VyLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgKSB8fCBudWxsO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9KSxcbiAgKTtcblxuICAvLyBUaGUgUmVzb2x2ZUVuZCBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBBbmd1bGFyIHJvdXRlciBoYXMgcmVzb2x2ZWQgdGhlIFVSTCBhbmRcbiAgLy8gdGhlIHBhcmFtZXRlcjwtPnZhbHVlIG1hcHBpbmcuIEl0IGhvbGRzIHRoZSBuZXcgcmVzb2x2ZWQgcm91dGVyIHN0YXRlIHdpdGhcbiAgLy8gdGhlIG1hcHBpbmcgYW5kIHRoZSBuZXcgVVJMLlxuICAvLyBPbmx5IEFmdGVyIHRoaXMgZXZlbnQsIHRoZSByb3V0ZSBpcyBhY3RpdmF0ZWQsIG1lYW5pbmcgdGhhdCB0aGUgdHJhbnNhY3Rpb25cbiAgLy8gY2FuIGJlIHVwZGF0ZWQgd2l0aCB0aGUgcGFyYW1ldGVyaXplZCByb3V0ZSBuYW1lIGJlZm9yZSBlLmcuIHRoZSByb3V0ZSdzIHJvb3RcbiAgLy8gY29tcG9uZW50IGlzIGluaXRpYWxpemVkLiBUaGlzIHNob3VsZCBiZSBlYXJseSBlbm91Z2ggYmVmb3JlIG91dGdvaW5nIHJlcXVlc3RzXG4gIC8vIGFyZSBtYWRlIGZyb20gdGhlIG5ldyByb3V0ZSwgd2l0aCB0aGUgZXhjZXB0aW9ucyBvZiByZXF1ZXN0cyBiZWluZyBtYWRlIGR1cmluZ1xuICAvLyBhIG5hdmlnYXRpb24uXG4gIHB1YmxpYyByZXNFbmQkOiBPYnNlcnZhYmxlPEV2ZW50PiA9IHRoaXMuX3JvdXRlci5ldmVudHMucGlwZShcbiAgICBmaWx0ZXIoKGV2ZW50KTogZXZlbnQgaXMgUmVzb2x2ZUVuZCA9PiBldmVudCBpbnN0YW5jZW9mIFJlc29sdmVFbmQpLFxuICAgIHRhcChldmVudCA9PiB7XG4gICAgICBjb25zdCByb3V0ZSA9IGdldFBhcmFtZXRlcml6ZWRSb3V0ZUZyb21TbmFwc2hvdChcbiAgICAgICAgKGV2ZW50LnN0YXRlIGFzIHVua25vd24gYXMgUm91dGVyU3RhdGUgJiB7IHJvb3Q6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QgfSkucm9vdCxcbiAgICAgICk7XG5cbiAgICAgIGlmIChyb3V0ZSkge1xuICAgICAgICBnZXRDdXJyZW50U2NvcGUoKS5zZXRUcmFuc2FjdGlvbk5hbWUocm91dGUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhY3RpdmVTcGFuID0gZ2V0QWN0aXZlU3BhbigpO1xuICAgICAgY29uc3Qgcm9vdFNwYW4gPSBhY3RpdmVTcGFuICYmIGdldFJvb3RTcGFuKGFjdGl2ZVNwYW4pO1xuXG4gICAgICBfdXBkYXRlU3BhbkF0dHJpYnV0ZXNGb3JQYXJhbWV0cml6ZWRVcmwocm91dGUsIHJvb3RTcGFuKTtcbiAgICB9KSxcbiAgKTtcblxuICBwdWJsaWMgbmF2RW5kJDogT2JzZXJ2YWJsZTxFdmVudD4gPSB0aGlzLl9yb3V0ZXIuZXZlbnRzLnBpcGUoXG4gICAgZmlsdGVyKFxuICAgICAgZXZlbnQgPT4gZXZlbnQgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uRW5kIHx8IGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvbkNhbmNlbCB8fCBldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25FcnJvcixcbiAgICApLFxuICAgIHRhcCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fcm91dGluZ1NwYW4pIHtcbiAgICAgICAgcnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgdGhpcy5fcm91dGluZ1NwYW4hLmVuZCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcm91dGluZ1NwYW4gPSBudWxsO1xuICAgICAgfVxuICAgIH0pLFxuICApO1xuXG4gIHByaXZhdGUgX3JvdXRpbmdTcGFuOiBTcGFuIHwgbnVsbDtcblxuICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAvKipcbiAgICogQHNlZSBfaXNQYWdlbG9hZE9uZ29pbmcoKVxuICAgKi9cbiAgcHJpdmF0ZSBfcGFnZWxvYWRPbmdvaW5nOiBib29sZWFuO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IF9yb3V0ZXI6IFJvdXRlcikge1xuICAgIHRoaXMuX3JvdXRpbmdTcGFuID0gbnVsbDtcbiAgICB0aGlzLl9wYWdlbG9hZE9uZ29pbmcgPSB0cnVlO1xuXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZCh0aGlzLm5hdlN0YXJ0JC5zdWJzY3JpYmUoKSk7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZCh0aGlzLnJlc0VuZCQuc3Vic2NyaWJlKCkpO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQodGhpcy5uYXZFbmQkLnN1YnNjcmliZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gcHJldmVudCBtZW1vcnkgbGVha3Mgd2hlbiB0aGUgcm9vdCB2aWV3IGlzIGNyZWF0ZWQgYW5kIGRlc3Ryb3llZCBtdWx0aXBsZSB0aW1lcyxcbiAgICogc2luY2UgYHN1YnNjcmliZWAgY2FsbGJhY2tzIGNhcHR1cmUgYHRoaXNgIGFuZCBwcmV2ZW50IG1hbnkgcmVzb3VyY2VzIGZyb20gYmVpbmcgR0MnZC5cbiAgICovXG4gIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXZSBvbmx5IF9hdm9pZF8gY3JlYXRpbmcgYSBuYXZpZ2F0aW9uIHJvb3Qgc3BhbiBpbiBvbmUgY2FzZTpcbiAgICpcbiAgICogVGhlcmUgaXMgYW4gb25nb2luZyBwYWdlbG9hZCBzcGFuIEFORCB0aGUgcm91dGVyIGRpZG4ndCB5ZXQgZW1pdCB0aGUgZmlyc3QgbmF2aWdhdGlvbiBzdGFydCBldmVudFxuICAgKlxuICAgKiBUaGUgZmlyc3QgbmF2aWdhdGlvbiBzdGFydCBldmVudCB3aWxsIGNyZWF0ZSB0aGUgY2hpbGQgcm91dGluZyBzcGFuXG4gICAqIGFuZCB1cGRhdGUgdGhlIHBhZ2Vsb2FkIHJvb3Qgc3BhbiBuYW1lIG9uIFJlc29sdmVFbmQuXG4gICAqXG4gICAqIFRoZXJlJ3MgYW4gZWRnZSBjYXNlIHdlIG5lZWQgdG8gYXZvaWQgaGVyZTogSWYgdGhlIHJvdXRlciBmaXJlcyB0aGUgZmlyc3QgbmF2aWdhdGlvbiBzdGFydCBldmVudFxuICAgKiBfYWZ0ZXJfIHRoZSBwYWdlbG9hZCByb290IHNwYW4gZmluaXNoZWQuIFRoaXMgaXMgd2h5IHdlIGNoZWNrIGZvciB0aGUgcGFnZWxvYWQgcm9vdCBzcGFuLlxuICAgKiBQb3NzaWJsZSByZWFsLXdvcmxkIHNjZW5hcmlvOiBBbmd1bGFyIGFwcGxpY2F0aW9uIGFuZC9vciByb3V0ZXIgaXMgYm9vdHN0cmFwcGVkIGFmdGVyIHRoZSBwYWdlbG9hZFxuICAgKiBpZGxlIHJvb3Qgc3BhbiBmaW5pc2hlZFxuICAgKlxuICAgKiBUaGUgb3ZlcmFsbCByYXRpb25hbGUgaXM6XG4gICAqIC0gaWYgd2UgYWxyZWFkeSBhdm9pZGVkIGNyZWF0aW5nIGEgbmF2aWdhdGlvbiByb290IHNwYW4gb25jZSwgd2UgZG9uJ3QgYXZvaWQgaXQgYWdhaW5cbiAgICogICAoaS5lLiBzZXQgYF9wYWdlbG9hZE9uZ29pbmdgIHRvIGBmYWxzZWApXG4gICAqIC0gaWYgYF9wYWdlbG9hZE9uZ29pbmdgIGlzIGFscmVhZHkgYGZhbHNlYCwgY3JlYXRlIGEgbmF2aWdhdGlvbiByb290IHNwYW5cbiAgICogLSBpZiB0aGVyZSdzIG5vIGFjdGl2ZS9wYWdlbG9hZCByb290IHNwYW4sIGNyZWF0ZSBhIG5hdmlnYXRpb24gcm9vdCBzcGFuXG4gICAqIC0gb25seSBpZiB0aGVyZSdzIGFuIG9uZ29pbmcgcGFnZWxvYWQgcm9vdCBzcGFuIEFORCBgX3BhZ2Vsb2FkT25nb2luZ2AgaXMgc3RpbGwgYHRydWUsXG4gICAqICAgZG9uJ3QgY3JlYXRlIGEgbmF2aWdhdGlvbiByb290IHNwYW5cbiAgICovXG4gIHByaXZhdGUgX2lzUGFnZWxvYWRPbmdvaW5nKCk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5fcGFnZWxvYWRPbmdvaW5nKSB7XG4gICAgICAvLyBwYWdlbG9hZCBpcyBhbHJlYWR5IGZpbmlzaGVkLCBubyBuZWVkIHRvIHVwZGF0ZVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2ZVNwYW4gPSBnZXRBY3RpdmVTcGFuKCk7XG4gICAgaWYgKCFhY3RpdmVTcGFuKSB7XG4gICAgICB0aGlzLl9wYWdlbG9hZE9uZ29pbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCByb290U3BhbiA9IGdldFJvb3RTcGFuKGFjdGl2ZVNwYW4pO1xuXG4gICAgdGhpcy5fcGFnZWxvYWRPbmdvaW5nID0gc3BhblRvSlNPTihyb290U3Bhbikub3AgPT09ICdwYWdlbG9hZCc7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2Vsb2FkT25nb2luZztcbiAgfVxufVxuXG5jb25zdCBVTktOT1dOX0NPTVBPTkVOVCA9ICd1bmtub3duJztcblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhcHR1cmUgaW5pdGlhbGl6YXRpb24gbGlmZWN5Y2xlIG9mIHRoZSB3aG9sZSBjb21wb25lbnQuXG4gKi9cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1t0cmFjZV0nIH0pXG5leHBvcnQgY2xhc3MgVHJhY2VEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQge1xuICBASW5wdXQoJ3RyYWNlJykgcHVibGljIGNvbXBvbmVudE5hbWU/OiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBfdHJhY2luZ1NwYW4/OiBTcGFuO1xuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiBPbkluaXQgbGlmZWN5Y2xlIG1ldGhvZFxuICAgKiBAaW5oZXJpdGRvY1xuICAgKi9cbiAgcHVibGljIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5jb21wb25lbnROYW1lKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudE5hbWUgPSBVTktOT1dOX0NPTVBPTkVOVDtcbiAgICB9XG5cbiAgICBpZiAoZ2V0QWN0aXZlU3BhbigpKSB7XG4gICAgICB0aGlzLl90cmFjaW5nU3BhbiA9IHJ1bk91dHNpZGVBbmd1bGFyKCgpID0+XG4gICAgICAgIHN0YXJ0SW5hY3RpdmVTcGFuKHtcbiAgICAgICAgICBuYW1lOiBgPCR7dGhpcy5jb21wb25lbnROYW1lfT5gLFxuICAgICAgICAgIG9wOiBBTkdVTEFSX0lOSVRfT1AsXG4gICAgICAgICAgYXR0cmlidXRlczogeyBbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dOiAnYXV0by51aS5hbmd1bGFyLnRyYWNlX2RpcmVjdGl2ZScgfSxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiBBZnRlclZpZXdJbml0IGxpZmVjeWNsZSBtZXRob2RcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3RyYWNpbmdTcGFuKSB7XG4gICAgICBydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB0aGlzLl90cmFjaW5nU3BhbiEuZW5kKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEEgbW9kdWxlIHNlcnZlcyBhcyBhIHNpbmdsZSBjb21waWxhdGlvbiB1bml0IGZvciB0aGUgYFRyYWNlRGlyZWN0aXZlYCBhbmQgY2FuIGJlIHJlLXVzZWQgYnkgYW55IG90aGVyIG1vZHVsZS5cbiAqL1xuQE5nTW9kdWxlKHtcbiAgZGVjbGFyYXRpb25zOiBbVHJhY2VEaXJlY3RpdmVdLFxuICBleHBvcnRzOiBbVHJhY2VEaXJlY3RpdmVdLFxufSlcbmV4cG9ydCBjbGFzcyBUcmFjZU1vZHVsZSB7fVxuXG5pbnRlcmZhY2UgVHJhY2VDbGFzc09wdGlvbnMge1xuICAvKipcbiAgICogTmFtZSBvZiB0aGUgY2xhc3NcbiAgICovXG4gIG5hbWU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogRGVjb3JhdG9yIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2FwdHVyZSBpbml0aWFsaXphdGlvbiBsaWZlY3ljbGUgb2YgdGhlIHdob2xlIGNvbXBvbmVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFRyYWNlQ2xhc3Mob3B0aW9ucz86IFRyYWNlQ2xhc3NPcHRpb25zKTogQ2xhc3NEZWNvcmF0b3Ige1xuICBsZXQgdHJhY2luZ1NwYW46IFNwYW47XG5cbiAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzICovXG4gIHJldHVybiB0YXJnZXQgPT4ge1xuICAgIGNvbnN0IG9yaWdpbmFsT25Jbml0ID0gdGFyZ2V0LnByb3RvdHlwZS5uZ09uSW5pdDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHRhcmdldC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoLi4uYXJnczogYW55W10pOiBSZXR1cm5UeXBlPHR5cGVvZiBvcmlnaW5hbE9uSW5pdD4ge1xuICAgICAgdHJhY2luZ1NwYW4gPSBydW5PdXRzaWRlQW5ndWxhcigoKSA9PlxuICAgICAgICBzdGFydEluYWN0aXZlU3Bhbih7XG4gICAgICAgICAgb25seUlmUGFyZW50OiB0cnVlLFxuICAgICAgICAgIG5hbWU6IGA8JHtvcHRpb25zICYmIG9wdGlvbnMubmFtZSA/IG9wdGlvbnMubmFtZSA6ICd1bm5hbWVkJ30+YCxcbiAgICAgICAgICBvcDogQU5HVUxBUl9JTklUX09QLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFtTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTl06ICdhdXRvLnVpLmFuZ3VsYXIudHJhY2VfY2xhc3NfZGVjb3JhdG9yJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KSxcbiAgICAgICk7XG5cbiAgICAgIGlmIChvcmlnaW5hbE9uSW5pdCkge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxPbkluaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG9yaWdpbmFsQWZ0ZXJWaWV3SW5pdCA9IHRhcmdldC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgdGFyZ2V0LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoLi4uYXJnczogYW55W10pOiBSZXR1cm5UeXBlPHR5cGVvZiBvcmlnaW5hbEFmdGVyVmlld0luaXQ+IHtcbiAgICAgIGlmICh0cmFjaW5nU3Bhbikge1xuICAgICAgICBydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB0cmFjaW5nU3Bhbi5lbmQoKSk7XG4gICAgICB9XG4gICAgICBpZiAob3JpZ2luYWxBZnRlclZpZXdJbml0KSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbEFmdGVyVmlld0luaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MgKi9cbn1cblxuaW50ZXJmYWNlIFRyYWNlTWV0aG9kT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBtZXRob2QgKGlzIGFkZGVkIHRvIHRoZSB0cmFjaW5nIHNwYW4pXG4gICAqL1xuICBuYW1lPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIERlY29yYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhcHR1cmUgYSBzaW5nbGUgbGlmZWN5Y2xlIG1ldGhvZHMgb2YgdGhlIGNvbXBvbmVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFRyYWNlTWV0aG9kKG9wdGlvbnM/OiBUcmFjZU1ldGhvZE9wdGlvbnMpOiBNZXRob2REZWNvcmF0b3Ige1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICByZXR1cm4gKHRhcmdldDogT2JqZWN0LCBwcm9wZXJ0eUtleTogc3RyaW5nIHwgc3ltYm9sLCBkZXNjcmlwdG9yOiBQcm9wZXJ0eURlc2NyaXB0b3IpID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbE1ldGhvZCA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gKC4uLmFyZ3M6IGFueVtdKTogUmV0dXJuVHlwZTx0eXBlb2Ygb3JpZ2luYWxNZXRob2Q+IHtcbiAgICAgIGNvbnN0IG5vdyA9IHRpbWVzdGFtcEluU2Vjb25kcygpO1xuXG4gICAgICBydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgIHN0YXJ0SW5hY3RpdmVTcGFuKHtcbiAgICAgICAgICBvbmx5SWZQYXJlbnQ6IHRydWUsXG4gICAgICAgICAgbmFtZTogYDwke29wdGlvbnMgJiYgb3B0aW9ucy5uYW1lID8gb3B0aW9ucy5uYW1lIDogJ3VubmFtZWQnfT5gLFxuICAgICAgICAgIG9wOiBgJHtBTkdVTEFSX09QfS4ke1N0cmluZyhwcm9wZXJ0eUtleSl9YCxcbiAgICAgICAgICBzdGFydFRpbWU6IG5vdyxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dOiAnYXV0by51aS5hbmd1bGFyLnRyYWNlX21ldGhvZF9kZWNvcmF0b3InLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pLmVuZChub3cpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChvcmlnaW5hbE1ldGhvZCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgIHJldHVybiBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICB9O1xufVxuXG4vKipcbiAqIFRha2VzIHRoZSBwYXJhbWV0ZXJpemVkIHJvdXRlIGZyb20gYSBnaXZlbiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90IGFuZCBjb25jYXRlbmF0ZXMgdGhlIHNuYXBzaG90J3NcbiAqIGNoaWxkIHJvdXRlIHdpdGggaXRzIHBhcmVudCB0byBwcm9kdWNlIHRoZSBjb21wbGV0ZSBwYXJhbWV0ZXJpemVkIFVSTCBvZiB0aGUgYWN0aXZhdGVkIHJvdXRlLlxuICogVGhpcyBoYXBwZW5zIHJlY3Vyc2l2ZWx5IHVudGlsIHRoZSBsYXN0IGNoaWxkIChpLmUuIHRoZSBlbmQgb2YgdGhlIFVSTCkgaXMgcmVhY2hlZC5cbiAqXG4gKiBAcGFyYW0gcm91dGUgdGhlIEFjdGl2YXRlZFJvdXRlU25hcHNob3Qgb2Ygd2hpY2ggaXRzIHBhdGggYW5kIGl0cyBjaGlsZCdzIHBhdGggaXMgY29uY2F0ZW5hdGVkXG4gKlxuICogQHJldHVybnMgdGhlIGNvbmNhdGVuYXRlZCBwYXJhbWV0ZXJpemVkIHJvdXRlIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyYW1ldGVyaXplZFJvdXRlRnJvbVNuYXBzaG90KHJvdXRlPzogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCB8IG51bGwpOiBzdHJpbmcge1xuICBjb25zdCBwYXJ0czogc3RyaW5nW10gPSBbXTtcblxuICBsZXQgY3VycmVudFJvdXRlID0gcm91dGUgJiYgcm91dGUuZmlyc3RDaGlsZDtcbiAgd2hpbGUgKGN1cnJlbnRSb3V0ZSkge1xuICAgIGNvbnN0IHBhdGggPSBjdXJyZW50Um91dGUgJiYgY3VycmVudFJvdXRlLnJvdXRlQ29uZmlnICYmIGN1cnJlbnRSb3V0ZS5yb3V0ZUNvbmZpZy5wYXRoO1xuICAgIGlmIChwYXRoID09PSBudWxsIHx8IHBhdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcGFydHMucHVzaChwYXRoKTtcbiAgICBjdXJyZW50Um91dGUgPSBjdXJyZW50Um91dGUuZmlyc3RDaGlsZDtcbiAgfVxuXG4gIGNvbnN0IGZ1bGxQYXRoID0gcGFydHMuZmlsdGVyKHBhcnQgPT4gcGFydCkuam9pbignLycpO1xuICByZXR1cm4gZnVsbFBhdGggPyBgLyR7ZnVsbFBhdGh9L2AgOiAnLyc7XG59XG4iXX0=